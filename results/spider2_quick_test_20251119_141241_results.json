{
  "timestamp": "2025-11-19T14:12:41.090081",
  "dataset_type": "spider2-lite",
  "experiments": {
    "config": {
      "name": "spider2_quick_test",
      "models": [
        "qwen/qwen3-coder-30b-a3b-instruct"
      ],
      "strategy": "spider2_basic",
      "max_examples": 3
    },
    "experiments": {
      "qwen3-coder-30b-a3b-instruct_spider2_basic": {
        "summary": {
          "total_examples": 3,
          "successful_executions": 2,
          "execution_accuracy": 0.6666666666666666,
          "successful_examples": 2
        },
        "entries": [
          {
            "instance_id": "local002",
            "question": "Can you calculate the 5-day symmetric moving average of predicted toy sales for December 5 to 8, 2018, using daily sales data from January 1, 2017, to August 29, 2018, with a simple linear regression model? Finally provide the sum of those four 5-day moving averages?",
            "database": "E_commerce",
            "predicted_sql": "SELECT SUM(ma_5day) AS sum_of_moving_averages FROM ( SELECT date(order_purchase_timestamp) AS sale_date, AVG(SUM(price)) OVER ( ORDER BY date(order_purchase_timestamp) ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS ma_5day FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE p.product_category_name = 'toys' AND date(order_purchase_timestamp) BETWEEN '2017-01-01' AND '2018-08-29' GROUP BY date(order_purchase_timestamp) HAVING date(order_purchase_timestamp) BETWEEN '2018-12-05' AND '2018-12-08' ) subquery",
            "gold_sql": "",
            "execution_success": true,
            "execution_match": false,
            "error": null,
            "llm_response": "SELECT SUM(ma_5day) AS sum_of_moving_averages\nFROM (\n    SELECT \n        date(order_purchase_timestamp) AS sale_date,\n        AVG(SUM(price)) OVER (\n            ORDER BY date(order_purchase_timestamp)\n            ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n        ) AS ma_5day\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE p.product_category_name = 'toys'\n      AND date(order_purchase_timestamp) BETWEEN '2017-01-01' AND '2018-08-29'\n    GROUP BY date(order_purchase_timestamp)\n    HAVING date(order_purchase_timestamp) BETWEEN '2018-12-05' AND '2018-12-08'\n) subquery;",
            "performance": {
              "response_time": 6.0875701904296875,
              "tokens_used": 83.2,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            },
            "execution_rows": 1,
            "execution_columns": 1
          },
          {
            "instance_id": "local003",
            "question": "According to the RFM definition document, calculate the average sales per order for each customer within distinct RFM segments, considering only 'delivered' orders. Use the customer unique identifier. Clearly define how to calculate Recency based on the latest purchase timestamp and specify the criteria for classifying RFM segments. The average sales should be computed as the total spend divided by the total number of orders. Please analyze and report the differences in average sales across the RFM segments",
            "database": "E_commerce",
            "predicted_sql": "SELECT rfm_segments.customer_unique_id, rfm_segments.rfm_segment, SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order FROM ( SELECT c.customer_unique_id, CASE WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 1 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-60 days') THEN 2 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-90 days') THEN 3 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-180 days') THEN 4 ELSE 5 END AS recency_score, COUNT(DISTINCT o.order_id) AS frequency_score, SUM(oi.price) AS monetary_score, CASE WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Champions' WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 2 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Can''t Lose Them' WHEN COUNT(DISTINCT o.order_id) BETWEEN 3 AND 6 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Hibernating' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Lost' WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Loyal Customers' WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Needs Attention' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 8 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Recent Users' WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Potential Loyalists' WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Price Sensitive' WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Promising' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-90 days') AND datetime('now', '-60 days') THEN 'About to Sleep' ELSE 'Other' END AS rfm_segment FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_status = 'delivered' GROUP BY c.customer_unique_id ) AS rfm_segments GROUP BY rfm_segments.customer_unique_id, rfm_segments.rfm_segment ORDER BY rfm_segments.rfm_segment",
            "gold_sql": "WITH RecencyScore AS (\n    SELECT customer_unique_id,\n           MAX(order_purchase_timestamp) AS last_purchase,\n           NTILE(5) OVER (ORDER BY MAX(order_purchase_timestamp) DESC) AS recency\n    FROM orders\n        JOIN customers USING (customer_id)\n    WHERE order_status = 'delivered'\n    GROUP BY customer_unique_id\n),\nFrequencyScore AS (\n    SELECT customer_unique_id,\n           COUNT(order_id) AS total_orders,\n           NTILE(5) OVER (ORDER BY COUNT(order_id) DESC) AS frequency\n    FROM orders\n        JOIN customers USING (customer_id)\n    WHERE order_status = 'delivered'\n    GROUP BY customer_unique_id\n),\nMonetaryScore AS (\n    SELECT customer_unique_id,\n           SUM(price) AS total_spent,\n           NTILE(5) OVER (ORDER BY SUM(price) DESC) AS monetary\n    FROM orders\n        JOIN order_items USING (order_id)\n        JOIN customers USING (customer_id)\n    WHERE order_status = 'delivered'\n    GROUP BY customer_unique_id\n),\n\n-- 2. Assign each customer to a group\nRFM AS (\n    SELECT last_purchase, total_orders, total_spent,\n        CASE\n            WHEN recency = 1 AND frequency + monetary IN (1, 2, 3, 4) THEN \"Champions\"\n            WHEN recency IN (4, 5) AND frequency + monetary IN (1, 2) THEN \"Can't Lose Them\"\n            WHEN recency IN (4, 5) AND frequency + monetary IN (3, 4, 5, 6) THEN \"Hibernating\"\n            WHEN recency IN (4, 5) AND frequency + monetary IN (7, 8, 9, 10) THEN \"Lost\"\n            WHEN recency IN (2, 3) AND frequency + monetary IN (1, 2, 3, 4) THEN \"Loyal Customers\"\n            WHEN recency = 3 AND frequency + monetary IN (5, 6) THEN \"Needs Attention\"\n            WHEN recency = 1 AND frequency + monetary IN (7, 8) THEN \"Recent Users\"\n            WHEN recency = 1 AND frequency + monetary IN (5, 6) OR\n                recency = 2 AND frequency + monetary IN (5, 6, 7, 8) THEN \"Potentital Loyalists\"\n            WHEN recency = 1 AND frequency + monetary IN (9, 10) THEN \"Price Sensitive\"\n            WHEN recency = 2 AND frequency + monetary IN (9, 10) THEN \"Promising\"\n            WHEN recency = 3 AND frequency + monetary IN (7, 8, 9, 10) THEN \"About to Sleep\"\n        END AS RFM_Bucket\n    FROM RecencyScore\n        JOIN FrequencyScore USING (customer_unique_id)\n        JOIN MonetaryScore USING (customer_unique_id)\n)\n\nSELECT RFM_Bucket, \n       AVG(total_spent / total_orders) AS avg_sales_per_customer\nFROM RFM\nGROUP BY RFM_Bucket",
            "execution_success": false,
            "execution_match": false,
            "error": "Execution failed on sql 'SELECT rfm_segments.customer_unique_id, rfm_segments.rfm_segment, SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order FROM ( SELECT c.customer_unique_id, CASE WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 1 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-60 days') THEN 2 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-90 days') THEN 3 WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-180 days') THEN 4 ELSE 5 END AS recency_score, COUNT(DISTINCT o.order_id) AS frequency_score, SUM(oi.price) AS monetary_score, CASE WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Champions' WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 2 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Can''t Lose Them' WHEN COUNT(DISTINCT o.order_id) BETWEEN 3 AND 6 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Hibernating' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Lost' WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Loyal Customers' WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Needs Attention' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 8 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Recent Users' WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Potential Loyalists' WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Price Sensitive' WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Promising' WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-90 days') AND datetime('now', '-60 days') THEN 'About to Sleep' ELSE 'Other' END AS rfm_segment FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_status = 'delivered' GROUP BY c.customer_unique_id ) AS rfm_segments GROUP BY rfm_segments.customer_unique_id, rfm_segments.rfm_segment ORDER BY rfm_segments.rfm_segment': no such column: o.order_id",
            "llm_response": "SELECT \n    rfm_segments.customer_unique_id,\n    rfm_segments.rfm_segment,\n    SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order\nFROM (\n    SELECT \n        c.customer_unique_id,\n        CASE \n            WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 1\n            WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-60 days') THEN 2\n            WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-90 days') THEN 3\n            WHEN MAX(o.order_purchase_timestamp) >= datetime('now', '-180 days') THEN 4\n            ELSE 5\n        END AS recency_score,\n        COUNT(DISTINCT o.order_id) AS frequency_score,\n        SUM(oi.price) AS monetary_score,\n        CASE \n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Champions'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 2 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Can''t Lose Them'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 3 AND 6 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Hibernating'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND (MAX(o.order_purchase_timestamp) < datetime('now', '-30 days') OR MAX(o.order_purchase_timestamp) IS NULL) THEN 'Lost'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 1 AND 4 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Loyal Customers'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Needs Attention'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 8 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Recent Users'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 5 AND 6 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Potential Loyalists'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) >= datetime('now', '-30 days') THEN 'Price Sensitive'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 9 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-60 days') AND datetime('now', '-30 days') THEN 'Promising'\n            WHEN COUNT(DISTINCT o.order_id) BETWEEN 7 AND 10 AND MAX(o.order_purchase_timestamp) BETWEEN datetime('now', '-90 days') AND datetime('now', '-60 days') THEN 'About to Sleep'\n            ELSE 'Other'\n        END AS rfm_segment\n    FROM customers c\n    JOIN orders o ON c.customer_id = o.customer_id\n    JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.order_status = 'delivered'\n    GROUP BY c.customer_unique_id\n) AS rfm_segments\nGROUP BY rfm_segments.customer_unique_id, rfm_segments.rfm_segment\nORDER BY rfm_segments.rfm_segment;",
            "performance": {
              "response_time": 20.964892864227295,
              "tokens_used": 390.0,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            }
          },
          {
            "instance_id": "local004",
            "question": "Could you tell me the number of orders, average payment per order and customer lifespan in weeks of the 3 custumers with the highest average payment per order, where the lifespan is calculated by subtracting the earliest purchase date from the latest purchase date in days, dividing by seven, and if the result is less than seven days, setting it to 1.0?",
            "database": "E_commerce",
            "predicted_sql": "SELECT COUNT(o.order_id) AS number_of_orders, AVG(op.payment_value) AS average_payment_per_order, CASE WHEN (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 < 7 THEN 1.0 ELSE (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 / 7.0 END AS customer_lifespan_in_weeks FROM orders o JOIN order_payments op ON o.order_id = op.order_id WHERE o.customer_id IN ( SELECT o2.customer_id FROM orders o2 JOIN order_payments op2 ON o2.order_id = op2.order_id GROUP BY o2.customer_id ORDER BY AVG(op2.payment_value) DESC LIMIT 3 ) GROUP BY o.customer_id ORDER BY AVG(op.payment_value) DESC LIMIT 3",
            "gold_sql": "WITH CustomerData AS (\n    SELECT\n        customer_unique_id,\n        COUNT(DISTINCT orders.order_id) AS order_count,\n        SUM(payment_value) AS total_payment,\n        JULIANDAY(MIN(order_purchase_timestamp)) AS first_order_day,\n        JULIANDAY(MAX(order_purchase_timestamp)) AS last_order_day\n    FROM customers\n        JOIN orders USING (customer_id)\n        JOIN order_payments USING (order_id)\n    GROUP BY customer_unique_id\n)\nSELECT\n    customer_unique_id,\n    order_count AS PF,\n    ROUND(total_payment / order_count, 2) AS AOV,\n    CASE\n        WHEN (last_order_day - first_order_day) < 7 THEN\n            1\n        ELSE\n            (last_order_day - first_order_day) / 7\n        END AS ACL\nFROM CustomerData\nORDER BY AOV DESC\nLIMIT 3",
            "execution_success": true,
            "execution_match": false,
            "error": null,
            "llm_response": "SELECT \n    COUNT(o.order_id) AS number_of_orders,\n    AVG(op.payment_value) AS average_payment_per_order,\n    CASE \n        WHEN (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 < 7 THEN 1.0\n        ELSE (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 / 7.0\n    END AS customer_lifespan_in_weeks\nFROM orders o\nJOIN order_payments op ON o.order_id = op.order_id\nWHERE o.customer_id IN (\n    SELECT o2.customer_id\n    FROM orders o2\n    JOIN order_payments op2 ON o2.order_id = op2.order_id\n    GROUP BY o2.customer_id\n    ORDER BY AVG(op2.payment_value) DESC\n    LIMIT 3\n)\nGROUP BY o.customer_id\nORDER BY AVG(op.payment_value) DESC\nLIMIT 3;",
            "performance": {
              "response_time": 2.4430840015411377,
              "tokens_used": 96.2,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            },
            "execution_rows": 3,
            "execution_columns": 3
          }
        ]
      }
    }
  }
}