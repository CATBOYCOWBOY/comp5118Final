{
  "timestamp": "2025-11-19T14:07:52.265893",
  "dataset_type": "spider2-lite",
  "experiments": {
    "config": {
      "name": "spider2_quick_test",
      "models": [
        "qwen/qwen3-coder-30b-a3b-instruct"
      ],
      "strategy": "spider2_basic",
      "max_examples": 5
    },
    "experiments": {
      "qwen3-coder-30b-a3b-instruct_spider2_basic": {
        "summary": {
          "total_examples": 5,
          "successful_executions": 3,
          "execution_accuracy": 0.6,
          "successful_examples": 3
        },
        "entries": [
          {
            "instance_id": "local002",
            "question": "Can you calculate the 5-day symmetric moving average of predicted toy sales for December 5 to 8, 2018, using daily sales data from January 1, 2017, to August 29, 2018, with a simple linear regression model? Finally provide the sum of those four 5-day moving averages?",
            "database": "E_commerce",
            "predicted_sql": "SELECT SUM(ma_5day) AS sum_of_moving_averages FROM ( SELECT date(order_purchase_timestamp) AS sale_date, AVG(SUM(price)) OVER ( ORDER BY date(order_purchase_timestamp) ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS ma_5day FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE p.product_category_name = 'toys' AND date(order_purchase_timestamp) BETWEEN '2017-01-01' AND '2018-08-29' GROUP BY date(order_purchase_timestamp) HAVING date(order_purchase_timestamp) BETWEEN '2018-12-05' AND '2018-12-08' ) subquery",
            "extracted_sql": "SELECT SUM(ma_5day) AS sum_of_moving_averages FROM ( SELECT date(order_purchase_timestamp) AS sale_date, AVG(SUM(price)) OVER ( ORDER BY date(order_purchase_timestamp) ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS ma_5day FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE p.product_category_name = 'toys' AND date(order_purchase_timestamp) BETWEEN '2017-01-01' AND '2018-08-29' GROUP BY date(order_purchase_timestamp) HAVING date(order_purchase_timestamp) BETWEEN '2018-12-05' AND '2018-12-08' ) subquery",
            "execution_success": true,
            "execution_match": false,
            "error": null,
            "llm_response": "SELECT SUM(ma_5day) AS sum_of_moving_averages\nFROM (\n    SELECT \n        date(order_purchase_timestamp) AS sale_date,\n        AVG(SUM(price)) OVER (\n            ORDER BY date(order_purchase_timestamp)\n            ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING\n        ) AS ma_5day\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE p.product_category_name = 'toys'\n      AND date(order_purchase_timestamp) BETWEEN '2017-01-01' AND '2018-08-29'\n    GROUP BY date(order_purchase_timestamp)\n    HAVING date(order_purchase_timestamp) BETWEEN '2018-12-05' AND '2018-12-08'\n) subquery;",
            "performance": {
              "response_time": 7.541404485702515,
              "tokens_used": 83.2,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            },
            "execution_rows": 1,
            "execution_columns": 1
          },
          {
            "instance_id": "local003",
            "question": "According to the RFM definition document, calculate the average sales per order for each customer within distinct RFM segments, considering only 'delivered' orders. Use the customer unique identifier. Clearly define how to calculate Recency based on the latest purchase timestamp and specify the criteria for classifying RFM segments. The average sales should be computed as the total spend divided by the total number of orders. Please analyze and report the differences in average sales across the RFM segments",
            "database": "E_commerce",
            "predicted_sql": "SELECT rfm_segment, AVG(avg_sales_per_order) AS avg_sales_per_order FROM ( SELECT c.customer_unique_id, CASE WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Champions' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 1 AND 2 THEN 'Can''t Lose Them' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 3 AND 6 THEN 'Hibernating' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'Lost' WHEN (recency_score = 2 OR recency_score = 3) AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Loyal Customers' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Needs Attention' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 7 AND 8 THEN 'Recent Users' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Potential Loyalists' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 5 AND 8 THEN 'Potential Loyalists' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Price Sensitive' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Promising' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'About to Sleep' ELSE 'Other' END AS rfm_segment, SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_status = 'delivered' GROUP BY c.customer_unique_id HAVING MAX(o.order_purchase_timestamp) IS NOT NULL AND COUNT(o.order_id) > 0 ) subquery GROUP BY rfm_segment ORDER BY avg_sales_per_order DESC",
            "extracted_sql": "SELECT rfm_segment, AVG(avg_sales_per_order) AS avg_sales_per_order FROM ( SELECT c.customer_unique_id, CASE WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Champions' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 1 AND 2 THEN 'Can''t Lose Them' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 3 AND 6 THEN 'Hibernating' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'Lost' WHEN (recency_score = 2 OR recency_score = 3) AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Loyal Customers' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Needs Attention' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 7 AND 8 THEN 'Recent Users' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Potential Loyalists' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 5 AND 8 THEN 'Potential Loyalists' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Price Sensitive' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Promising' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'About to Sleep' ELSE 'Other' END AS rfm_segment, SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_status = 'delivered' GROUP BY c.customer_unique_id HAVING MAX(o.order_purchase_timestamp) IS NOT NULL AND COUNT(o.order_id) > 0 ) subquery GROUP BY rfm_segment ORDER BY avg_sales_per_order DESC",
            "execution_success": false,
            "execution_match": false,
            "error": "Execution failed on sql 'SELECT rfm_segment, AVG(avg_sales_per_order) AS avg_sales_per_order FROM ( SELECT c.customer_unique_id, CASE WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Champions' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 1 AND 2 THEN 'Can''t Lose Them' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 3 AND 6 THEN 'Hibernating' WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'Lost' WHEN (recency_score = 2 OR recency_score = 3) AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Loyal Customers' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Needs Attention' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 7 AND 8 THEN 'Recent Users' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Potential Loyalists' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 5 AND 8 THEN 'Potential Loyalists' WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Price Sensitive' WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Promising' WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'About to Sleep' ELSE 'Other' END AS rfm_segment, SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_status = 'delivered' GROUP BY c.customer_unique_id HAVING MAX(o.order_purchase_timestamp) IS NOT NULL AND COUNT(o.order_id) > 0 ) subquery GROUP BY rfm_segment ORDER BY avg_sales_per_order DESC': no such column: recency_score",
            "llm_response": "SELECT \n    rfm_segment,\n    AVG(avg_sales_per_order) AS avg_sales_per_order\nFROM (\n    SELECT \n        c.customer_unique_id,\n        CASE \n            WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Champions'\n            WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 1 AND 2 THEN 'Can''t Lose Them'\n            WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 3 AND 6 THEN 'Hibernating'\n            WHEN (recency_score = 4 OR recency_score = 5) AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'Lost'\n            WHEN (recency_score = 2 OR recency_score = 3) AND (frequency_score + monetary_score) BETWEEN 1 AND 4 THEN 'Loyal Customers'\n            WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Needs Attention'\n            WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 7 AND 8 THEN 'Recent Users'\n            WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 5 AND 6 THEN 'Potential Loyalists'\n            WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 5 AND 8 THEN 'Potential Loyalists'\n            WHEN recency_score = 1 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Price Sensitive'\n            WHEN recency_score = 2 AND (frequency_score + monetary_score) BETWEEN 9 AND 10 THEN 'Promising'\n            WHEN recency_score = 3 AND (frequency_score + monetary_score) BETWEEN 7 AND 10 THEN 'About to Sleep'\n            ELSE 'Other'\n        END AS rfm_segment,\n        SUM(oi.price) / COUNT(DISTINCT o.order_id) AS avg_sales_per_order\n    FROM customers c\n    JOIN orders o ON c.customer_id = o.customer_id\n    JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.order_status = 'delivered'\n    GROUP BY c.customer_unique_id\n    HAVING \n        MAX(o.order_purchase_timestamp) IS NOT NULL AND\n        COUNT(o.order_id) > 0\n) subquery\nGROUP BY rfm_segment\nORDER BY avg_sales_per_order DESC;",
            "performance": {
              "response_time": 5.2754106521606445,
              "tokens_used": 334.1,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            }
          },
          {
            "instance_id": "local004",
            "question": "Could you tell me the number of orders, average payment per order and customer lifespan in weeks of the 3 custumers with the highest average payment per order, where the lifespan is calculated by subtracting the earliest purchase date from the latest purchase date in days, dividing by seven, and if the result is less than seven days, setting it to 1.0?",
            "database": "E_commerce",
            "predicted_sql": "SELECT COUNT(o.order_id) AS number_of_orders, AVG(op.payment_value) AS average_payment_per_order, CASE WHEN (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 < 7 THEN 1.0 ELSE (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 / 7.0 END AS customer_lifespan_weeks FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_payments op ON o.order_id = op.order_id GROUP BY c.customer_id ORDER BY AVG(op.payment_value) DESC LIMIT 3",
            "extracted_sql": "SELECT COUNT(o.order_id) AS number_of_orders, AVG(op.payment_value) AS average_payment_per_order, CASE WHEN (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 < 7 THEN 1.0 ELSE (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 / 7.0 END AS customer_lifespan_weeks FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_payments op ON o.order_id = op.order_id GROUP BY c.customer_id ORDER BY AVG(op.payment_value) DESC LIMIT 3",
            "execution_success": true,
            "execution_match": false,
            "error": null,
            "llm_response": "SELECT \n    COUNT(o.order_id) AS number_of_orders,\n    AVG(op.payment_value) AS average_payment_per_order,\n    CASE \n        WHEN (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 < 7 THEN 1.0\n        ELSE (MAX(o.order_purchase_timestamp) - MIN(o.order_purchase_timestamp)) / 86400.0 / 7.0\n    END AS customer_lifespan_weeks\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nJOIN order_payments op ON o.order_id = op.order_id\nGROUP BY c.customer_id\nORDER BY AVG(op.payment_value) DESC\nLIMIT 3;",
            "performance": {
              "response_time": 4.182945013046265,
              "tokens_used": 71.5,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            },
            "execution_rows": 3,
            "execution_columns": 3
          },
          {
            "instance_id": "local007",
            "question": "Could you help me calculate the average single career span value in years for all baseball players? Please precise the result as a float number. First, calculate the difference in years, months, and days between the debut and final game dates. For each player, the career span is computed as the sum of the absolute number of years, plus the absolute number of months divided by 12, plus the absolute number of days divided by 365. Round each part to two decimal places before summing. Finally, average the career spans and round the result to a float number.",
            "database": "Baseball",
            "predicted_sql": "SELECT CAST(AVG( CAST(SUBSTR(p.debut, 1, 4) AS INTEGER) - CAST(SUBSTR(p.final_game, 1, 4) AS INTEGER) AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 6, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 6, 2) AS INTEGER)) / 12.0 AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 9, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 9, 2) AS INTEGER)) / 365.0 AS FLOAT) ) AS FLOAT) AS average_career_span FROM player p WHERE p.debut IS NOT NULL AND p.final_game IS NOT NULL",
            "extracted_sql": "SELECT CAST(AVG( CAST(SUBSTR(p.debut, 1, 4) AS INTEGER) - CAST(SUBSTR(p.final_game, 1, 4) AS INTEGER) AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 6, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 6, 2) AS INTEGER)) / 12.0 AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 9, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 9, 2) AS INTEGER)) / 365.0 AS FLOAT) ) AS FLOAT) AS average_career_span FROM player p WHERE p.debut IS NOT NULL AND p.final_game IS NOT NULL",
            "execution_success": false,
            "execution_match": false,
            "error": "Execution failed on sql 'SELECT CAST(AVG( CAST(SUBSTR(p.debut, 1, 4) AS INTEGER) - CAST(SUBSTR(p.final_game, 1, 4) AS INTEGER) AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 6, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 6, 2) AS INTEGER)) / 12.0 AS FLOAT) + CAST((CAST(SUBSTR(p.debut, 9, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 9, 2) AS INTEGER)) / 365.0 AS FLOAT) ) AS FLOAT) AS average_career_span FROM player p WHERE p.debut IS NOT NULL AND p.final_game IS NOT NULL': near \"AS\": syntax error",
            "llm_response": "SELECT CAST(AVG(\n    CAST(SUBSTR(p.debut, 1, 4) AS INTEGER) - CAST(SUBSTR(p.final_game, 1, 4) AS INTEGER) AS FLOAT) +\n    CAST((CAST(SUBSTR(p.debut, 6, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 6, 2) AS INTEGER)) / 12.0 AS FLOAT) +\n    CAST((CAST(SUBSTR(p.debut, 9, 2) AS INTEGER) - CAST(SUBSTR(p.final_game, 9, 2) AS INTEGER)) / 365.0 AS FLOAT)\n) AS FLOAT) AS average_career_span\nFROM player p\nWHERE p.debut IS NOT NULL AND p.final_game IS NOT NULL;",
            "performance": {
              "response_time": 2.176173686981201,
              "tokens_used": 84.5,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            }
          },
          {
            "instance_id": "local008",
            "question": "I would like to know the given names of baseball players who have achieved the highest value of games played, runs, hits, and home runs, with their corresponding score values.",
            "database": "Baseball",
            "predicted_sql": "SELECT p.name_given, MAX(b.g) AS games_played, MAX(b.r) AS runs, MAX(b.h) AS hits, MAX(b.hr) AS home_runs FROM player p JOIN batting b ON p.player_id = b.player_id WHERE p.name_given IS NOT NULL GROUP BY p.name_given ORDER BY games_played DESC, runs DESC, hits DESC, home_runs DESC LIMIT 10",
            "extracted_sql": "SELECT p.name_given, MAX(b.g) AS games_played, MAX(b.r) AS runs, MAX(b.h) AS hits, MAX(b.hr) AS home_runs FROM player p JOIN batting b ON p.player_id = b.player_id WHERE p.name_given IS NOT NULL GROUP BY p.name_given ORDER BY games_played DESC, runs DESC, hits DESC, home_runs DESC LIMIT 10",
            "execution_success": true,
            "execution_match": false,
            "error": null,
            "llm_response": "SELECT p.name_given, MAX(b.g) AS games_played, MAX(b.r) AS runs, MAX(b.h) AS hits, MAX(b.hr) AS home_runs\nFROM player p\nJOIN batting b ON p.player_id = b.player_id\nWHERE p.name_given IS NOT NULL\nGROUP BY p.name_given\nORDER BY games_played DESC, runs DESC, hits DESC, home_runs DESC\nLIMIT 10",
            "performance": {
              "response_time": 2.658620834350586,
              "tokens_used": 57.2,
              "model": "qwen/qwen3-coder-30b-a3b-instruct"
            },
            "execution_rows": 10,
            "execution_columns": 5
          }
        ]
      }
    }
  }
}