{
  "config": {
    "name": "strategy_comparison",
    "models": [
      "qwen/qwen3-coder-30b-a3b-instruct"
    ],
    "strategies": [
      "multi_stage_simple"
    ],
    "max_examples": 2,
    "spider_path": "spider",
    "split": "dev"
  },
  "experiments": {
    "qwen3-coder-30b-a3b-instruct_multi_stage_simple": {
      "summary": {
        "total_examples": 2,
        "exact_match_count": 0,
        "exact_match_accuracy": 0.0,
        "component_match_count": 0,
        "component_match_accuracy": 0.0,
        "execution_match_count": 0,
        "execution_match_accuracy": 0.0,
        "successful_examples": 2
      },
      "entries": [
        {
          "entry_id": 1,
          "question": "Which regions speak Dutch or English?",
          "database": "world_1",
          "predicted_sql": "SELECT DISTINCT c.region\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE cl.language = 'Dutch' OR cl.language = 'English';",
          "extracted_sql": "SELECT DISTINCT c.region\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE cl.language = 'Dutch' OR cl.language = 'English';",
          "gold_sql": "SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  \"English\" OR T2.Language  =  \"Dutch\"",
          "llm_response": "Looking at the analysis, I need to find regions where Dutch or English is spoken. Let me think through this step by step:\n\n1. I need to join the `country` table with `countrylanguage` table to connect countries with their languages\n2. Filter for countries where the language is either 'Dutch' or 'English'\n3. Select the distinct regions (since multiple countries in a region might speak these languages)\n4. The foreign key relationship shows that `country.code` connects to `countrylanguage.countrycode`\n\nHere's the SQL query:\n\n```sql\nSELECT DISTINCT c.region\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE cl.language = 'Dutch' OR cl.language = 'English';\n```",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 2.4444477558135986,
            "tokens_used": 303,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        },
        {
          "entry_id": 2,
          "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
          "database": "world_1",
          "predicted_sql": "SELECT COUNT(DISTINCT cl.language) AS total_distinct_official_languages\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE c.indepyear < 1930 \n  AND cl.isofficial = 'T';",
          "extracted_sql": "SELECT COUNT(DISTINCT cl.language) AS total_distinct_official_languages\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE c.indepyear < 1930 \n  AND cl.isofficial = 'T';",
          "gold_sql": "SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  \"T\"",
          "llm_response": "Looking at the analysis, I need to find the total number of distinct official languages for countries founded before 1930.\n\nLet me break down the requirements:\n1. Countries founded before 1930 (independent year < 1930)\n2. Count distinct official languages for these countries\n3. Join country and countrylanguage tables to get the information\n\nHere's the SQL query:\n\n```sql\nSELECT COUNT(DISTINCT cl.language) AS total_distinct_official_languages\nFROM country c\nJOIN countrylanguage cl ON c.code = cl.countrycode\nWHERE c.indepyear < 1930 \n  AND cl.isofficial = 'T';\n```\n\nThis query:\n- Joins the country table with countrylanguage table using the country code\n- Filters for countries with independent year before 1930\n- Filters for official languages only (isofficial = 'T')\n- Counts the distinct languages to avoid counting the same language multiple times across different countries",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 7.350692510604858,
            "tokens_used": 367,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        }
      ]
    }
  },
  "summary": {
    "model_comparison": {
      "meta-llama/llama-3.1-8b-instruct": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 6.986799990336101,
        "total_tokens_sum": 70839,
        "error_rate_mean": 0.0
      },
      "qwen/qwen3-coder-30b-a3b-instruct": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 7.334305210529812,
        "total_tokens_sum": 32788,
        "error_rate_mean": 0.0
      }
    },
    "strategy_comparison": {
      "multi_stage_simple": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 4.639893126487732,
        "total_tokens_sum": 18109,
        "error_rate_mean": 0.0
      },
      "multi_stage": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 15.514844559487841,
        "total_tokens_sum": 51790,
        "error_rate_mean": 0.0
      },
      "multi_stage_no_analysis": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 8.384258254369099,
        "total_tokens_sum": 13834,
        "error_rate_mean": 0.0
      },
      "multi_stage_no_verification": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 7.046631956100464,
        "total_tokens_sum": 19894,
        "error_rate_mean": 0.0
      }
    }
  },
  "timestamp": "2025-11-18T19:52:04.818824"
}