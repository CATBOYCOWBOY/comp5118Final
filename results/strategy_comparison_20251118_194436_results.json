{
  "config": {
    "name": "strategy_comparison",
    "models": [
      "qwen/qwen3-coder-30b-a3b-instruct"
    ],
    "strategies": [
      "multi_stage_simple"
    ],
    "max_examples": 5,
    "spider_path": "spider",
    "split": "dev"
  },
  "experiments": {
    "qwen3-coder-30b-a3b-instruct_multi_stage_simple": {
      "summary": {
        "total_examples": 5,
        "exact_match_count": 0,
        "exact_match_accuracy": 0.0,
        "component_match_count": 1,
        "component_match_accuracy": 0.2,
        "execution_match_count": 0,
        "execution_match_accuracy": 0.0,
        "successful_examples": 5
      },
      "entries": [
        {
          "entry_id": 1,
          "question": "Show ids for all templates not used by any document.",
          "database": "cre_Doc_Template_Mgt",
          "predicted_sql": "SELECT template_id\nFROM templates\nWHERE template_id NOT IN (\n    SELECT DISTINCT template_id\n    FROM documents\n    WHERE template_id IS NOT NULL\n)\nORDER BY template_id;",
          "gold_sql": "SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents",
          "llm_response": "Based on the analysis, I need to find all template IDs that are not used by any document.\n\nLooking at the relationships:\n- The `templates` table contains template information with `template id`\n- The `documents` table contains documents with `template id` as a foreign key\n- To find templates not used by any document, I need to find templates whose IDs don't appear in the documents table\n\nHere's the SQL query:\n\n```sql\nSELECT template_id\nFROM templates\nWHERE template_id NOT IN (\n    SELECT DISTINCT template_id\n    FROM documents\n    WHERE template_id IS NOT NULL\n)\nORDER BY template_id;\n```\n\nAlternative approach using LEFT JOIN:\n\n```sql\nSELECT t.template_id\nFROM templates t\nLEFT JOIN documents d ON t.template_id = d.template_id\nWHERE d.template_id IS NULL\nORDER BY t.template_id;\n```\n\nBoth queries will return the IDs of all templates that are not referenced by any document. The second approach using LEFT JOIN is often more efficient and readable.",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 5.064913034439087,
            "tokens_used": 363,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        },
        {
          "entry_id": 2,
          "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
          "database": "car_1",
          "predicted_sql": "SELECT cn.model\nFROM cars_data cd\nJOIN car_names cn ON cd.id = cn.make_id\nWHERE cd.cylinders = 4\nORDER BY cd.horsepower DESC\nLIMIT 1;",
          "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;",
          "llm_response": "Looking at the analysis, I need to find the model with the most horsepower among all 4-cylinder cars.\n\nLet me trace through the relationships:\n- The `cars data` table contains `cylinders` and `horsepower` columns\n- The `car names` table links `make id` to `model` \n- The `model list` table contains `model` information\n- I need to filter for cars with 4 cylinders and find the one with maximum horsepower\n\nHere's my approach:\n1. Join `cars data` with `car names` to get model information\n2. Filter for cars with 4 cylinders\n3. Order by horsepower descending and limit to 1 to get the highest\n\n```sql\nSELECT cn.model\nFROM cars_data cd\nJOIN car_names cn ON cd.id = cn.make_id\nWHERE cd.cylinders = 4\nORDER BY cd.horsepower DESC\nLIMIT 1;\n```",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 13.706312656402588,
            "tokens_used": 370,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        },
        {
          "entry_id": 3,
          "question": "Which model of the car has the minimum horsepower?",
          "database": "car_1",
          "predicted_sql": "SELECT cn.make\nFROM cars_data cd\nJOIN car_names cn ON cd.id = cn.make_id\nWHERE cd.horsepower = (SELECT MIN(horsepower) FROM cars_data)",
          "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;",
          "llm_response": "Looking at the analysis, I need to find the car model with the minimum horsepower. Let me trace through the relationships:\n\n1. The `cars data` table contains the `horsepower` column\n2. The `car names` table links `make id` to `make` (which represents the model)\n3. The `model list` table contains `model` information\n4. The `car makers` table contains `maker` information\n\nTo get the model with minimum horsepower, I need to:\n- Join `cars data` with `car names` on `id = make id`\n- Find the record with minimum horsepower\n- Return the model name\n\n```sql\nSELECT cn.make\nFROM cars_data cd\nJOIN car_names cn ON cd.id = cn.make_id\nWHERE cd.horsepower = (SELECT MIN(horsepower) FROM cars_data)\n```",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 2.0470242500305176,
            "tokens_used": 347,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        },
        {
          "entry_id": 4,
          "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
          "database": "dog_kennels",
          "predicted_sql": "SELECT first_name, last_name, email_address\nFROM owners\nWHERE state LIKE '%North%';",
          "gold_sql": "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",
          "llm_response": "```sql\nSELECT first_name, last_name, email_address\nFROM owners\nWHERE state LIKE '%North%';\n```",
          "exact_match": false,
          "component_match": true,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 1.5360941886901855,
            "tokens_used": 333,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        },
        {
          "entry_id": 5,
          "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
          "database": "tvshow",
          "predicted_sql": "SELECT id \nFROM tv_channel \nWHERE id NOT IN (\n    SELECT DISTINCT channel \n    FROM cartoon \n    WHERE \"directed by\" = 'Ben Jones'\n)",
          "gold_sql": "SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'",
          "llm_response": "Looking at the analysis, I need to find TV channels that do not play any cartoons directed by Ben Jones.\n\nLet me break down the approach:\n1. First, I need to identify all cartoons directed by Ben Jones\n2. Then, I need to find all TV channels that DO play these cartoons\n3. Finally, I need to exclude those channels from all channels to get channels that do NOT play any cartoons by Ben Jones\n\n```sql\nSELECT id \nFROM tv_channel \nWHERE id NOT IN (\n    SELECT DISTINCT channel \n    FROM cartoon \n    WHERE \"directed by\" = 'Ben Jones'\n)\n```",
          "exact_match": false,
          "component_match": false,
          "execution_match": false,
          "error": null,
          "performance": {
            "response_time": 6.506458282470703,
            "tokens_used": 287,
            "model": "qwen/qwen3-coder-30b-a3b-instruct"
          }
        }
      ]
    }
  },
  "summary": {
    "model_comparison": {
      "meta-llama/llama-3.1-8b-instruct": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 6.986799990336101,
        "total_tokens_sum": 70839,
        "error_rate_mean": 0.0
      },
      "qwen/qwen3-coder-30b-a3b-instruct": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 9.744592506923373,
        "total_tokens_sum": 29421,
        "error_rate_mean": 0.0
      }
    },
    "strategy_comparison": {
      "multi_stage_simple": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 4.426799535751343,
        "total_tokens_sum": 14742,
        "error_rate_mean": 0.0
      },
      "multi_stage": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 15.514844559487841,
        "total_tokens_sum": 51790,
        "error_rate_mean": 0.0
      },
      "multi_stage_no_analysis": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 8.384258254369099,
        "total_tokens_sum": 13834,
        "error_rate_mean": 0.0
      },
      "multi_stage_no_verification": {
        "exact_match_accuracy_mean": 0.0,
        "execution_accuracy_mean": 0.0,
        "average_response_time_mean": 7.046631956100464,
        "total_tokens_sum": 19894,
        "error_rate_mean": 0.0
      }
    }
  },
  "timestamp": "2025-11-18T19:44:36.108076"
}